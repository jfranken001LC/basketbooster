import { GraphQLSchema } from "graphql";
/**
 * Interface for output fixture validation result
 */
export interface OutputValidationResult {
    errors: {
        message: string;
    }[];
    mutationName: string;
    resultParameterType: string | null;
}
/**
 * Validate output fixture by checking if it can be used as input to the corresponding mutation
 *
 * This approach leverages the fact that function output fixtures are designed to be used
 * as input parameters to GraphQL mutations. We can validate them by:
 * 1. Finding the mutation field and its parameter type in the schema
 * 2. Using GraphQL's coerceInputValue() to validate the fixture data against the expected input type
 *
 * @param {Object} outputFixtureData - The output fixture data to validate
 * @param {GraphQLSchema} originalSchema - The original GraphQL schema
 * @param {string} mutationName - The mutation field name (e.g., 'cartValidationsGenerateRun')
 * @param {string} resultParameterName - The parameter name in the mutation (usually 'result')
 * @returns {Object} Validation result with structure:
 *   - errors: { message: string }[] - Array of GraphQL coercion errors (empty if valid)
 *   - mutationName: string - The mutation name that was validated
 *   - resultParameterType: string|null - The GraphQL type of the result parameter
 */
export declare function validateFixtureOutput(outputFixtureData: Record<string, any>, originalSchema: GraphQLSchema, mutationName: string, resultParameterName?: string): Promise<OutputValidationResult>;
//# sourceMappingURL=validate-fixture-output.d.ts.map